/**
 * Generated by @openapi-codegen
 *
 * @version 0.3.0
 */
import * as reactQuery from '@tanstack/react-query';
import { useApiContext, ApiContext } from './apiContext';
import type * as Fetcher from './apiFetcher';
import { apiFetch } from './apiFetcher';
import type * as Schemas from './apiSchemas';

export type RootError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.HTTPError;
    }
  | {
      status: 401;
      payload: Schemas.HTTPError;
    }
  | {
      status: 404;
      payload: Schemas.HTTPError;
    }
>;

export type RootVariables = ApiContext['fetcherOptions'];

/**
 * Root endpoint.
 */
export const fetchRoot = (variables: RootVariables, signal?: AbortSignal) => apiFetch<Schemas.RootResponse, RootError, undefined, {}, {}, {}>({ url: '/api/v1/', method: 'get', ...variables, signal });

/**
 * Root endpoint.
 */
export const useRoot = <TData = Schemas.RootResponse>(variables: RootVariables, options?: Omit<reactQuery.UseQueryOptions<Schemas.RootResponse, RootError, TData>, 'queryKey' | 'queryFn' | 'initialData'>) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useApiContext(options);
  return reactQuery.useQuery<Schemas.RootResponse, RootError, TData>({
    queryKey: queryKeyFn({ path: '/api/v1/', operationId: 'root', variables }),
    queryFn: ({ signal }) => fetchRoot({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions
  });
};

export type HealthError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.HTTPError;
    }
  | {
      status: 401;
      payload: Schemas.HTTPError;
    }
  | {
      status: 404;
      payload: Schemas.HTTPError;
    }
>;

export type HealthVariables = ApiContext['fetcherOptions'];

/**
 * Health endpoint.
 */
export const fetchHealth = (variables: HealthVariables, signal?: AbortSignal) => apiFetch<Schemas.HealthResponse, HealthError, undefined, {}, {}, {}>({ url: '/api/v1/health', method: 'get', ...variables, signal });

/**
 * Health endpoint.
 */
export const useHealth = <TData = Schemas.HealthResponse>(variables: HealthVariables, options?: Omit<reactQuery.UseQueryOptions<Schemas.HealthResponse, HealthError, TData>, 'queryKey' | 'queryFn' | 'initialData'>) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useApiContext(options);
  return reactQuery.useQuery<Schemas.HealthResponse, HealthError, TData>({
    queryKey: queryKeyFn({ path: '/api/v1/health', operationId: 'health', variables }),
    queryFn: ({ signal }) => fetchHealth({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions
  });
};

export type ErrorError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.HTTPError;
    }
  | {
      status: 401;
      payload: Schemas.HTTPError;
    }
  | {
      status: 404;
      payload: Schemas.HTTPError;
    }
  | {
      status: 500;
      payload: void;
    }
>;

export type ErrorVariables = ApiContext['fetcherOptions'];

/**
 * Error endpoint, which need to be used to test the exception monitor middleware.
 */
export const fetchError = (variables: ErrorVariables, signal?: AbortSignal) => apiFetch<undefined, ErrorError, undefined, {}, {}, {}>({ url: '/api/v1/error', method: 'get', ...variables, signal });

/**
 * Error endpoint, which need to be used to test the exception monitor middleware.
 */
export const useError = <TData = undefined>(variables: ErrorVariables, options?: Omit<reactQuery.UseQueryOptions<undefined, ErrorError, TData>, 'queryKey' | 'queryFn' | 'initialData'>) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useApiContext(options);
  return reactQuery.useQuery<undefined, ErrorError, TData>({
    queryKey: queryKeyFn({ path: '/api/v1/error', operationId: 'error', variables }),
    queryFn: ({ signal }) => fetchError({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions
  });
};

export type VersionError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.HTTPError;
    }
  | {
      status: 401;
      payload: Schemas.HTTPError;
    }
  | {
      status: 404;
      payload: Schemas.HTTPError;
    }
>;

export type VersionVariables = ApiContext['fetcherOptions'];

/**
 * Version endpoint.
 */
export const fetchVersion = (variables: VersionVariables, signal?: AbortSignal) => apiFetch<Schemas.VersionResponse, VersionError, undefined, {}, {}, {}>({ url: '/api/v1/version', method: 'get', ...variables, signal });

/**
 * Version endpoint.
 */
export const useVersion = <TData = Schemas.VersionResponse>(variables: VersionVariables, options?: Omit<reactQuery.UseQueryOptions<Schemas.VersionResponse, VersionError, TData>, 'queryKey' | 'queryFn' | 'initialData'>) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useApiContext(options);
  return reactQuery.useQuery<Schemas.VersionResponse, VersionError, TData>({
    queryKey: queryKeyFn({ path: '/api/v1/version', operationId: 'version', variables }),
    queryFn: ({ signal }) => fetchVersion({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions
  });
};

export type ReadAccountsError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.HTTPError;
    }
  | {
      status: 401;
      payload: Schemas.HTTPError;
    }
  | {
      status: 404;
      payload: Schemas.HTTPError;
    }
>;

export type ReadAccountsResponse = Schemas.Account[];

export type ReadAccountsVariables = ApiContext['fetcherOptions'];

/**
 * Retrieve a list of accounts.
 *
 * This endpoint requires authentication with the "admin" scope.
 */
export const fetchReadAccounts = (variables: ReadAccountsVariables, signal?: AbortSignal) => apiFetch<ReadAccountsResponse, ReadAccountsError, undefined, {}, {}, {}>({ url: '/api/v1/account/', method: 'get', ...variables, signal });

/**
 * Retrieve a list of accounts.
 *
 * This endpoint requires authentication with the "admin" scope.
 */
export const useReadAccounts = <TData = ReadAccountsResponse>(variables: ReadAccountsVariables, options?: Omit<reactQuery.UseQueryOptions<ReadAccountsResponse, ReadAccountsError, TData>, 'queryKey' | 'queryFn' | 'initialData'>) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useApiContext(options);
  return reactQuery.useQuery<ReadAccountsResponse, ReadAccountsError, TData>({
    queryKey: queryKeyFn({ path: '/api/v1/account/', operationId: 'readAccounts', variables }),
    queryFn: ({ signal }) => fetchReadAccounts({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions
  });
};

export type CreateAccountError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.HTTPError;
    }
  | {
      status: 401;
      payload: Schemas.HTTPError;
    }
  | {
      status: 404;
      payload: Schemas.HTTPError;
    }
  | {
      status: 422;
      payload: Schemas.HTTPValidationError;
    }
>;

export type CreateAccountVariables = {
  body: Schemas.AccountCreate;
} & ApiContext['fetcherOptions'];

/**
 * Create a new account.
 */
export const fetchCreateAccount = (variables: CreateAccountVariables, signal?: AbortSignal) => apiFetch<Schemas.Account, CreateAccountError, Schemas.AccountCreate, {}, {}, {}>({ url: '/api/v1/account/', method: 'post', ...variables, signal });

/**
 * Create a new account.
 */
export const useCreateAccount = (options?: Omit<reactQuery.UseMutationOptions<Schemas.Account, CreateAccountError, CreateAccountVariables>, 'mutationFn'>) => {
  const { fetcherOptions } = useApiContext();
  return reactQuery.useMutation<Schemas.Account, CreateAccountError, CreateAccountVariables>({
    mutationFn: (variables: CreateAccountVariables) => fetchCreateAccount({ ...fetcherOptions, ...variables }),
    ...options
  });
};

export type ReadAccountPathParams = {
  accountId: number;
};

export type ReadAccountError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.HTTPError;
    }
  | {
      status: 401;
      payload: Schemas.HTTPError;
    }
  | {
      status: 404;
      payload: Schemas.HTTPError;
    }
  | {
      status: 422;
      payload: Schemas.HTTPValidationError;
    }
>;

export type ReadAccountVariables = {
  pathParams: ReadAccountPathParams;
} & ApiContext['fetcherOptions'];

/**
 * Retrieve an account by ID.
 *
 * This endpoint requires authentication with the "admin" scope.
 */
export const fetchReadAccount = (variables: ReadAccountVariables, signal?: AbortSignal) => apiFetch<Schemas.Account, ReadAccountError, undefined, {}, {}, ReadAccountPathParams>({ url: '/api/v1/account/{accountId}', method: 'get', ...variables, signal });

/**
 * Retrieve an account by ID.
 *
 * This endpoint requires authentication with the "admin" scope.
 */
export const useReadAccount = <TData = Schemas.Account>(variables: ReadAccountVariables, options?: Omit<reactQuery.UseQueryOptions<Schemas.Account, ReadAccountError, TData>, 'queryKey' | 'queryFn' | 'initialData'>) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useApiContext(options);
  return reactQuery.useQuery<Schemas.Account, ReadAccountError, TData>({
    queryKey: queryKeyFn({ path: '/api/v1/account/{accountId}', operationId: 'readAccount', variables }),
    queryFn: ({ signal }) => fetchReadAccount({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions
  });
};

export type UpdateAccountPathParams = {
  accountId: number;
};

export type UpdateAccountError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.HTTPError;
    }
  | {
      status: 401;
      payload: Schemas.HTTPError;
    }
  | {
      status: 404;
      payload: Schemas.HTTPError;
    }
  | {
      status: 422;
      payload: Schemas.HTTPValidationError;
    }
>;

export type UpdateAccountVariables = {
  body?: Schemas.AccountUpdate;
  pathParams: UpdateAccountPathParams;
} & ApiContext['fetcherOptions'];

/**
 * Update an account by ID.
 *
 * This endpoint requires authentication with the "admin" scope.
 */
export const fetchUpdateAccount = (variables: UpdateAccountVariables, signal?: AbortSignal) =>
  apiFetch<Schemas.Account, UpdateAccountError, Schemas.AccountUpdate, {}, {}, UpdateAccountPathParams>({ url: '/api/v1/account/{accountId}', method: 'patch', ...variables, signal });

/**
 * Update an account by ID.
 *
 * This endpoint requires authentication with the "admin" scope.
 */
export const useUpdateAccount = (options?: Omit<reactQuery.UseMutationOptions<Schemas.Account, UpdateAccountError, UpdateAccountVariables>, 'mutationFn'>) => {
  const { fetcherOptions } = useApiContext();
  return reactQuery.useMutation<Schemas.Account, UpdateAccountError, UpdateAccountVariables>({
    mutationFn: (variables: UpdateAccountVariables) => fetchUpdateAccount({ ...fetcherOptions, ...variables }),
    ...options
  });
};

export type DeleteAccountPathParams = {
  accountId: number;
};

export type DeleteAccountError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.HTTPError;
    }
  | {
      status: 401;
      payload: Schemas.HTTPError;
    }
  | {
      status: 404;
      payload: Schemas.HTTPError;
    }
  | {
      status: 422;
      payload: Schemas.HTTPValidationError;
    }
>;

export type DeleteAccountVariables = {
  pathParams: DeleteAccountPathParams;
} & ApiContext['fetcherOptions'];

/**
 * Delete an account by ID.
 *
 * This endpoint requires authentication with the "admin" scope.
 */
export const fetchDeleteAccount = (variables: DeleteAccountVariables, signal?: AbortSignal) =>
  apiFetch<Schemas.Account, DeleteAccountError, undefined, {}, {}, DeleteAccountPathParams>({ url: '/api/v1/account/{accountId}', method: 'delete', ...variables, signal });

/**
 * Delete an account by ID.
 *
 * This endpoint requires authentication with the "admin" scope.
 */
export const useDeleteAccount = (options?: Omit<reactQuery.UseMutationOptions<Schemas.Account, DeleteAccountError, DeleteAccountVariables>, 'mutationFn'>) => {
  const { fetcherOptions } = useApiContext();
  return reactQuery.useMutation<Schemas.Account, DeleteAccountError, DeleteAccountVariables>({
    mutationFn: (variables: DeleteAccountVariables) => fetchDeleteAccount({ ...fetcherOptions, ...variables }),
    ...options
  });
};

export type LoginError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.HTTPError;
    }
  | {
      status: 401;
      payload: Schemas.HTTPError;
    }
  | {
      status: 404;
      payload: Schemas.HTTPError;
    }
  | {
      status: 422;
      payload: Schemas.HTTPValidationError;
    }
>;

export type LoginVariables = {
  body: Schemas.BodyLogin;
} & ApiContext['fetcherOptions'];

/**
 * Logs in a user and returns an access token.
 */
export const fetchLogin = (variables: LoginVariables, signal?: AbortSignal) => apiFetch<Schemas.Token, LoginError, Schemas.BodyLogin, {}, {}, {}>({ url: '/api/v1/auth/login/', method: 'post', ...variables, signal });

/**
 * Logs in a user and returns an access token.
 */
export const useLogin = (options?: Omit<reactQuery.UseMutationOptions<Schemas.Token, LoginError, LoginVariables>, 'mutationFn'>) => {
  const { fetcherOptions } = useApiContext();
  return reactQuery.useMutation<Schemas.Token, LoginError, LoginVariables>({
    mutationFn: (variables: LoginVariables) => fetchLogin({ ...fetcherOptions, ...variables }),
    ...options
  });
};

export type ReadAccountMeError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.HTTPError;
    }
  | {
      status: 401;
      payload: Schemas.HTTPError;
    }
  | {
      status: 404;
      payload: Schemas.HTTPError;
    }
>;

export type ReadAccountMeVariables = ApiContext['fetcherOptions'];

/**
 * Returns the current user's account information.
 */
export const fetchReadAccountMe = (variables: ReadAccountMeVariables, signal?: AbortSignal) => apiFetch<Schemas.Account, ReadAccountMeError, undefined, {}, {}, {}>({ url: '/api/v1/auth/me/', method: 'get', ...variables, signal });

/**
 * Returns the current user's account information.
 */
export const useReadAccountMe = <TData = Schemas.Account>(variables: ReadAccountMeVariables, options?: Omit<reactQuery.UseQueryOptions<Schemas.Account, ReadAccountMeError, TData>, 'queryKey' | 'queryFn' | 'initialData'>) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useApiContext(options);
  return reactQuery.useQuery<Schemas.Account, ReadAccountMeError, TData>({
    queryKey: queryKeyFn({ path: '/api/v1/auth/me/', operationId: 'readAccountMe', variables }),
    queryFn: ({ signal }) => fetchReadAccountMe({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions
  });
};

export type UpdateAccountMeError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.HTTPError;
    }
  | {
      status: 401;
      payload: Schemas.HTTPError;
    }
  | {
      status: 404;
      payload: Schemas.HTTPError;
    }
  | {
      status: 422;
      payload: Schemas.HTTPValidationError;
    }
>;

export type UpdateAccountMeVariables = {
  body?: Schemas.OwnAccountUpdate;
} & ApiContext['fetcherOptions'];

/**
 * Updates the current user's account information.
 */
export const fetchUpdateAccountMe = (variables: UpdateAccountMeVariables, signal?: AbortSignal) => apiFetch<Schemas.Account, UpdateAccountMeError, Schemas.OwnAccountUpdate, {}, {}, {}>({ url: '/api/v1/auth/me/', method: 'put', ...variables, signal });

/**
 * Updates the current user's account information.
 */
export const useUpdateAccountMe = (options?: Omit<reactQuery.UseMutationOptions<Schemas.Account, UpdateAccountMeError, UpdateAccountMeVariables>, 'mutationFn'>) => {
  const { fetcherOptions } = useApiContext();
  return reactQuery.useMutation<Schemas.Account, UpdateAccountMeError, UpdateAccountMeVariables>({
    mutationFn: (variables: UpdateAccountMeVariables) => fetchUpdateAccountMe({ ...fetcherOptions, ...variables }),
    ...options
  });
};

export type UpdateBalancePathParams = {
  accountId: number;
};

export type UpdateBalanceError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.HTTPError;
    }
  | {
      status: 401;
      payload: Schemas.HTTPError;
    }
  | {
      status: 404;
      payload: Schemas.HTTPError;
    }
  | {
      status: 422;
      payload: Schemas.HTTPValidationError;
    }
>;

export type UpdateBalanceVariables = {
  body: Schemas.BalanceUpdate;
  pathParams: UpdateBalancePathParams;
} & ApiContext['fetcherOptions'];

/**
 * Modify the balance of an account by ID.
 *
 * This endpoint requires authentication with the "admin" scope.
 */
export const fetchUpdateBalance = (variables: UpdateBalanceVariables, signal?: AbortSignal) =>
  apiFetch<Schemas.Balance, UpdateBalanceError, Schemas.BalanceUpdate, {}, {}, UpdateBalancePathParams>({ url: '/api/v1/balance/{accountId}', method: 'put', ...variables, signal });

/**
 * Modify the balance of an account by ID.
 *
 * This endpoint requires authentication with the "admin" scope.
 */
export const useUpdateBalance = (options?: Omit<reactQuery.UseMutationOptions<Schemas.Balance, UpdateBalanceError, UpdateBalanceVariables>, 'mutationFn'>) => {
  const { fetcherOptions } = useApiContext();
  return reactQuery.useMutation<Schemas.Balance, UpdateBalanceError, UpdateBalanceVariables>({
    mutationFn: (variables: UpdateBalanceVariables) => fetchUpdateBalance({ ...fetcherOptions, ...variables }),
    ...options
  });
};

export type UpdateStockPathParams = {
  accountId: number;
  symbol: string;
};

export type UpdateStockError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.HTTPError;
    }
  | {
      status: 401;
      payload: Schemas.HTTPError;
    }
  | {
      status: 404;
      payload: Schemas.HTTPError;
    }
  | {
      status: 422;
      payload: Schemas.HTTPValidationError;
    }
>;

export type UpdateStockVariables = {
  body: Schemas.StockUpdate;
  pathParams: UpdateStockPathParams;
} & ApiContext['fetcherOptions'];

/**
 * Modify the stock of an account by ID and symbol.
 *
 * This endpoint requires authentication with the "admin" scope.
 */
export const fetchUpdateStock = (variables: UpdateStockVariables, signal?: AbortSignal) =>
  apiFetch<Schemas.Stock, UpdateStockError, Schemas.StockUpdate, {}, {}, UpdateStockPathParams>({ url: '/api/v1/stock/{accountId}/{symbol}', method: 'put', ...variables, signal });

/**
 * Modify the stock of an account by ID and symbol.
 *
 * This endpoint requires authentication with the "admin" scope.
 */
export const useUpdateStock = (options?: Omit<reactQuery.UseMutationOptions<Schemas.Stock, UpdateStockError, UpdateStockVariables>, 'mutationFn'>) => {
  const { fetcherOptions } = useApiContext();
  return reactQuery.useMutation<Schemas.Stock, UpdateStockError, UpdateStockVariables>({
    mutationFn: (variables: UpdateStockVariables) => fetchUpdateStock({ ...fetcherOptions, ...variables }),
    ...options
  });
};

export type QueryOperation =
  | {
      path: '/api/v1/';
      operationId: 'root';
      variables: RootVariables;
    }
  | {
      path: '/api/v1/health';
      operationId: 'health';
      variables: HealthVariables;
    }
  | {
      path: '/api/v1/error';
      operationId: 'error';
      variables: ErrorVariables;
    }
  | {
      path: '/api/v1/version';
      operationId: 'version';
      variables: VersionVariables;
    }
  | {
      path: '/api/v1/account/';
      operationId: 'readAccounts';
      variables: ReadAccountsVariables;
    }
  | {
      path: '/api/v1/account/{accountId}';
      operationId: 'readAccount';
      variables: ReadAccountVariables;
    }
  | {
      path: '/api/v1/auth/me/';
      operationId: 'readAccountMe';
      variables: ReadAccountMeVariables;
    };
